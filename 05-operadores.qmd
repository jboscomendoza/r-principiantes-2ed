# Operadores {#sec-operadores}
Los operadores son los s铆mbolos que, como nombre lo anticipa, le indican a R que se debe realizar un tipo de operaci贸n espec铆fica. En todos los lenguajes de programaci贸n, los operadores son sumamente importantes, al combinarlos con los datos y sus estructuras es que logramos hacer la mayor parte de nuestro trabajo.

Los tipos de operadores principales en R son los siguientes:

* Aritm茅ticos
* Relacionales
* L贸gicos
* De asignaci贸n

Familiarizarnos con los operadores nos dar谩 herramientas para manipular y transformar datos. 

Revisemos los diferentes tipos de operador.

## Operadores aritm茅ticos

Este tipo de operador es usado para operaciones aritm茅ticas. En R tenemos disponibles los siguientes operadores, que corresponden a las operaciones aritm茅ticas b谩sicas.

Operador  | Operaci贸n       | Ejemplo | Resultado
----      |----             |----     |----
`+`       | Suma            | `5 + 3` | 8
`-`       | Resta           | `5 - 3` | 2
`*`       | Multiplicaci贸n  | `5 * 3` | 18
`/`       | Divisi贸n        | `5 /3`  | 1.666667
`^`       | Potencia        | `5 ^ 3` | 125
`%%`      | Divisi贸n entera | `5 %% 3`| 2

Podemos realizar operaciones aritm茅ticas con datos de tipo **entero** y **num茅rico**.

Si escribimos una operaci贸n aritm茅tica en la consola de R y damos *Enter*, la operaci贸n se realiza y nos es devuelto su resultado.

```{r operacion_aritmetica_basica}
15 * 3
```

Cuando intentamos realizar una operaci贸n aritm茅tica con un tipo de dato que no sea entero o num茅rico, R primero intentar谩 coercionar ese dato a uno de tipo num茅rico. Si la coerci贸n es exitosa, se realizar谩 la operaci贸n normalmente, y si falla nos devolver谩 un error.

Por ejemplo, `4 + TRUE` se realizar谩 normalmente, coercionando `TRUE` a `1`.

```{r numerico_coercion}
4 + TRUE
```

En contraste, si intentamos la operaci贸n `4 + "1"` se nos devuelve un error.

```{r numerico_cadena}
#| error: true
4 + "1"
```

El mensaje *"non-numeric argument for binary operator"* aparecer谩 siempre que intentemos realizar una operaci贸n aritm茅tica con un argumento no num茅rico y que no puede coercionarse a tipo num茅rico. Si nos encontramos con este error, esto nos da una pista para encontrar la ra铆z del problema.

Cualquier operaci贸n aritm茅tica que intentemos con un dato `NA` siempre nos devolver谩 `NA` como resultado a menos que ocurra un error o un dato sea `NULL`.

```{r numerico_na}
#| error: true
NA - 66

21 * NA

NA ^ 13

"64.3" + NA
```

驴Qu茅 pasa si hacemos una operaci贸n con un dato `NULL`? Siempre nos devolver谩 un vector num茅rico vac铆o, incluso si uno de los datos es `NA`, a menos que ocurra un error.

```{r numerico_null}
#| error: true
NULL - 66

21 * NULL

NULL ^ 13

NULL + NA

"64.3" + NULL
```

### La divisi贸n entera

La divisi贸n entera o **m贸dulo** es un caso particular de la divisi贸n, que en lugar de devolver el cociente de la operaci贸n, nos devuelve el residuo.

Por ejemplo, si hacemos la divisi贸n `4 / 2` obtenemos su cociente, `2`.

```{r division_1}
4 / 2
```

Si hacemos una divisi贸n entera de 4 entre 2, el resultado ser谩 0, por ser una divisi贸n exacta que no tiene residuo.

```{r division_entera_1}
4 %% 2
```

En cambio, si hacemos una divisi贸n `5 / 2`, su resultado es `2.5`. Obtenemos una parte decimal en el resultados porque no podemos hacer una divisi贸n exacta entre estos dos n煤meros.

```{r division_2}
5 / 2
```

Por lo tanto, al hacer la divisi贸n entera de 5 entre 2, el resultado ser谩 1, el residuo de la divisi贸n.

```{r division_entera_2}
5 %% 2
```

## Operadores relacionales

Los operadores l贸gicos son usados para hacer comparaciones y siempre devuelven como resultado los valores l贸gicos `TRUE` o `FALSE` (verdadero o falso, respectivamente).

Operador| Comparaci贸n           | Ejemplo   | Resultado
----    |----                   |----       |----
`<`     | Menor que             | `5 < 3`   | `FALSE`
`>`     | Mayor que             | `5 > 3`   | `TRUE`
`<=`    | Menor o igual que     | `5 <= 3`  | `FALSE`
`>=`    | Mayor o igual que     | `5 >= 3`  | `TRUE`
`==`    | Exactamente igual que | `5 == 3`  | `FALSE`
`!=`    | No es igual que       | `5 != 3`  | `TRUE`

### Comparaci贸n de datos enteros o num茅ricos

Al comparar datos enteros o num茅ricos ocurre una comparaci贸n de magnitudes.

```{r comparacion_numerica}
16 > 8.5
16 < 8.5

-16 > -8.5
-16 < -8.5

8.5 >= 8.5
8.5 <= 8.5

8.5 == 8.5
16 == 8.5

16 != 8.5
16 != 8.5
```

### Comparaci贸n de cadenas de texto

Cuando usamos los operadores `>`, `>=`, `<` y `<=` con cadenas de texto, se hace una comparaci贸n por orden alfab茅tico. 

Por ejemplo, probemos si `"casa"` es mayor que `"barco"`.

```{r comparar_cadenas_1}
"casa" > "barco"
```

En este caso, es verdadero que la palabra "casa" tiene orden alfab茅tico mayor a "barco", pues empieza con "c" y esta letra tiene una posici贸n posterior a la "b" en el alfabeto.

Entonces, si comparamos `"barco" < "casa"` no es devuelto `FALSE`.

```{r comparar_cadenas_2}
"barco" < "casa"
```

La comparaci贸n es hecha letra por letra, de modo que `"casa"` tiene un orden alfab茅tico mayor que `"cama"` y menor que `"cava"`.

```{r comparar_cadenas_3}
"casa" > "cama"
"casa" > "cava"
```

Al comparar dos cadenas con `==` ambas deben ser exactamente iguales para que nos sea devuelto `TRUE`, si son parcialmente iguales obtenemos `FALSE`.

```{r comparar_cadenas_4}
"casa" == "casa"
"casa" == "casar"
```

Las comparaciones son sencibles a las letras may煤sculas y min煤sculas. Las letras may煤sculas tienen un orden mayor que las min煤sculas. 

```{r comparar_mayus}
"C" > "c"
"Barco" > "barco"
"barco" > "barCo"
```

### Comparaci贸n de factores

Si intentamos comparar dos factores se nos devuelve un valor `NA` y una advertencia de que la operaci贸n de relaci贸n no tiene significado para factores.

```{r comparar_factores_1}
factor("1") > factor("2")
```

Esto ocurre incluso cuando comparamos factores que forman parte del mismo vector.

```{r comparar_factores}
vector_factores <- factor(c("1", "2"))

vector_factores

vector_factores[1] > vector_factores[2]
```

### Comparaci贸n con datos l贸gicos

Al comparar valores l贸gicos, `TRUE` siempre es mayor que `FALSE`.

```{r comparar_logicos_1}
TRUE < FALSE
TRUE > FALSE
```

Naturalmente, `TRUE` y `FALSE` son iguales a s铆 mismos y diferentes entre s铆.

```{r comparar_logicos_2}
TRUE == TRUE
FALSE == FALSE
TRUE == FALSE
TRUE != FALSE
```

### Comparaci贸n con NA y NULL

Cualquier comparaci贸n con un dato `NA` nos devuelve `NA`, excepto al comparar con `NULL`.

```{r comparar_NA}
NA > 32
NA > "32"
NA > TRUE
```

Por su parte, cualquier comparaci贸n un dato `NULL` obtenemos un vector l贸gico vac铆o, incluso al comparar con un dato `NA`.

```{r comparar_NULL}
NULL < 32
NULL < "32"
NULL < TRUE
NULL < NA
```

### Comparaci贸n con datos de diferentes tipos

Si comparamos un dato num茅rico con una cadena de texto, el dato entero o num茅rico es coercionado a una cadena de texto y se seguir谩n las reglas de comparaci贸n para cadenas.

```{r comprar_cadena_numerico}
"1" == 1
"a" > 123000.75
"33" > 40
"33" > 22.1
```
Como las n煤meros en una cadena de texto tienen un orden alfab茅tico menor que las letras, generalmente una palabra ser谩 mayor que un dato entero o num茅rico

```{r}
"Alba" > 137018.75
"z贸calo" > 137018.75
```

Si comparamos un dato n煤merico con uno l贸gico, `TRUE` es coercionado a `1` y `FALSE` a 0.

```{r comparar_logico_numerico}
TRUE == 1
FALSE == 0
TRUE > 24
FALSE > 24
TRUE > -24
FALSE > -24
```

Si comparamos un valor l贸gico con una cadena de texto, este ser谩 coercionado a una cadena de texto, as铆 que se comparar谩n `"TRUE"` y `"FALSE"`, con las reglas de comparaci贸n para cadenas de texto.

```{r}
TRUE == "TRUE"
FALSE == "FALSE"
TRUE > "SOGA"
TRUE > "UMBRAL"
FALSE > "ETAPA"
FALSE > "HIGO"
```

## Operadores l贸gicos

Los operadores l贸gicos son usados para operaciones de **谩lgebra Booleana**, es decir, para describir relaciones l贸gicas, evalu谩ndolas como verdaderas (`TRUE`) o falsas (`FALSE`). 

Operador    | Nombre   |Operaci贸n                 | Ejemplo        | Resultado
----        |---       |----                      |----            |----
`a | b`     | O (OR)   | a **o** b es verdadero   | `TRUE | FALSE` | `TRUE`
`a & b`     | Y (AND)  | a **y** b son verdaderos | `TRUE & FALSE` | `FALSE`
`!a`        | NO (NOT) | a **no** es verdadero    | `!TRUE`        | `FALSE`

Estos operadores siempre devuelven `TRUE` o `FALSE`, sin importar el tipo de datos con los que se opere.

Los operadores `|` y `&` siguen estas reglas:

* `|` devuelve `TRUE` si cualquiera de los datos es evaluado como `TRUE`
* `&` solo devuelve `TRUE` si ambos datos son evaluados como `TRUE`
* `|` solo devuelve `FALSE` si ambos datos son evaluados como `FALSE`
* `&` devuelve `FALSE` si cualquiera de los datos es evaluado como `FALSE`

Adem谩s tenemos la funci贸n `isTRUE()` que comprueba si un valor es `TRUE`.

Funci贸n     | Operaci贸n                      | Ejemplo        | Resultado
---         |---                             |---             |---
`isTRUE(a)` | a **es** verdadero, afirmaci贸n | `isTRUE(TRUE)` | `TRUE`

### Operadores l贸gicos y evaluaci贸n de expresiones

En un sentido estricto, al usar estos operadores estamos combinando dos valor booleanos, pero una forma de entender estos operadores es que evaluan la veracidad ("truthiness", en ingl茅s) de dos objetos al mismo tiempo.

Cuando nuestros objetos son datos son de tipo l贸gico, esta evaluaci贸n es muy transparente, `TRUE | FALSE` nos devuelve `TRUE` mientras que `TRUE | FALSE` nos devuelve `TRUE`. Sin embargo, como podemos usar estos operadores con cualquier tipo de datos, estos primero se evaluan a `TRUE` or `FALSE` y lo mismo es cierto para el resultado de otras operaciones o funciones. 

Para explicar esto un poco m谩s, supongamos que tenemos dos mascotas, una llamada Menchi y la otra Tlaloc, que tienen los atributos que se muestran en la siguiente tabla.

Atributo         | Menchi  | Tlaloc 
---              |---        |---
Clase            | Mam铆fero  | Mam铆fero
Especie          | Perro     | Gato
Sexo             | Hembra    | Macho
N煤mero de patas  | 4         | 4
Pelaje           | Corto     | Largo

Vamos a evaluar algunas aformaciones sobre Menchi y Tlaloc.

* Menchi Y (`&`) Tlaloc son Mam铆feros

Tenemos que evaluar el atributo "Clase" de cada uno de ellos

* 驴La Clase de Menchi es Mamifero? Verdadero (`TRUE`)
* 驴La Clase de Tlaloc es Mamifero? Verdadero (`TRUE`)

Entonces:

* Menchi == `TRUE`
* Tlaloc == `TRUE`

Que podr铆amos representar as铆:

* `TRUE & TRUE` 

Que nos da como resultado `TRUE`. Es decir, es Verdadero que Menchi y Tlaloc son Mam铆feros.

Evalu茅mos una segunda afirmaci贸n:

* Menchi Y (`&`) Tlaloc son Perros

De nuevo, evaluamos el atributo correspondiente de ambos:

* 驴La Especie de Menchi es Perro? Verdadero (`TRUE`)
* 驴La Especie de Tlaloc es Gato? Falso (`FALSE`)

Entonces:

* Menchi == `TRUE`
* Tlaloc == `FALSE`

Y, por lo tanto:

* `TRUE & FALSE`

Que nos da como resultado `FALSE`. Es decir, es Falso que Menchi y Tlaloc son Perros.

Cambiemos nuestra afirmaci贸n:

* Menchi O (`|`) Tlaloc son Perros

No suena muy natural si lo decimos de esta manera. Cambiemos la formulaci贸n:

* Menchi O (`|`) Tlaloc es un Perro

Como ya vimos, para que el operador `|` (O, OR) devuelva `TRUE`, basta con que cualquier elementos sea `TRUE`, as铆 que podemos expresar esta afirmaci贸n de esta manera.

Ya conocemos el resultado de evaluar el atributo Especia de Menchi y Tlaloc.

* Menchi == `TRUE`
* Tlaloc == `FALSE`

Por lo tanto:

* `TRUE | FALSE`

Que nos da como resultado `TRUE`. Es decir, es Verdadero que Menchi o Tlaloc es un Perro.

Finalmente, tenemos una afirmaci贸n que usa `!` (NO, NOT).

* Menchi No (`!`) es Macho

En este ejemplo, esta afirmaci贸n es f谩cil de evaluar, pues s贸lo tenemos que mirar el atributo correspondiente para llegar al resultado `TRUE`, es Verdadero que Menchi No es Macho.

Pero podemos combinar esta afirmaci贸n otra, sobre Tlaloc.

* Menchi No (!) es Macho Y (`&`) Tlaloc es Macho

Sabemos que es Verdadero que Tlaloc es Macho, por lo tanto:

* `TRUE & TRUE` 

Que nos da como resultado `TRUE`, es Verdadero que Menchi No es Macho y Tlaloc es Macho.

Este 煤ltimo ejemplo es una peque帽a muestra de lo complejas que pueden ser las operaciones l贸gicas. En la siguiente secci贸n veremos c贸mo se combinan con operaciones relacionales.

### Operadores l贸gicos con operadores relacionales

Los operadores se pueden combinar para expresar relaciones complejas.

Por ejemplo, la negaci贸n `FALSE` Y `FALSE` dar谩 como resultado `TRUE`.
```{r}
!(FALSE | FALSE)
```

Tambi茅n podemos combinar operadores l贸gicos y relacionales. dado que esto 煤ltimos dan como resultado `TRUE` y `FALSE`.

```{r}
(4 < 6) | (6 == 6)
```

### Operadores l贸gicos con datos enteros y num茅ricos

Como revisamos en la [Secci贸n @sec-datos-coercion], los datos enteros y num茅ricos pueden coercionados a l贸gicos. Todos los valores enteros y num茅ricos distintos a `0` son coercionados a `TRUE`, mientras que `0` siempre es coercionado a `FALSE`.

Por ejemplo, `5 | 0` devuelve `TRUE` porque el n煤mero `5` es coercionado a `TRUE` y `0` es conercionado a `FALSE.

```{r coercion_numerico}
5 | 0
```

Podemos comprobar lo anterior con la funci贸n `isTRUE()`.

```{r coercion_istrue}
isTRUE(0)
isTRUE(5)
```

Por lo tanto, `5 | FALSE` devuelve `TRUE` y `0 & TRUE` devuelve `FALSE`.

```{r}
5 | FALSE
0 & FALSE
```

### Operadores l贸gicos con cadenas de texto

Si intentamos una operaci贸n l贸gica con una cadena de texto obtenemos siempre un error.

```{r}
#| error: true
"TRUE" & FALSE
"FALSE" | TRUE
"a" | FALSE
"Z" & TRUE
!"casa"
```

### Operadores l贸gicos con NA y NULL

Al usar el operador `|` (OR), si cualquiera de los datos es `TRUE`, obtenemos `TRUE` aunque el otro dato sea `NA` o `NULL`

```{r OR_NA_NULL_TRUE}
NA | TRUE
NULL | TRUE
```

Pero si un dato es `NA` y el otro es `FALSE`, obtenemos `NA`.

```{r OR_NA_NULL_FALSE}
NA | FALSE
```

Y si un dato es `NULL` y el otro es `FALSE`, obtenemos un vector l贸gico vac铆o.

```{r OR_NULL_FALSE}
NULL | FALSE
```

Lo anterior aplica para el caso de `&` (AND), si uno de los datos es `NA`, obtenemos `NA`, y si uno es `NULL`, obtenemos un vector l贸gico vac铆o.

```{r AND_NA_NULL}
NA & TRUE
NA & FALSE
NULL & TRUE
NULL & FALSE
```

Si negamos `NA` con `!` (NOT) obtenemos `NA`.

```{r NOT_NA}
!NA
```

Pero si negamos `NULL` se nos devuelve un error.

```{r NOT_NULL}
#| error: true
!NULL
```

## Operadores de asignaci贸n
Este es probablemente el operador m谩s importante de todos, pues nos permite asignar datos a variables.

Operador  | Operaci贸n   
----      |----         
`<-`      | Asigna un valor a una variable
`=`       | Asigna un valor a una variable

Aunque podemos usar el signo igual para una asignaci贸n, a lo largo de este libro utilizaremos `<-`, por ser caracter铆stico de R y f谩cil de reconocer visualmente.

Despu茅s de realizar la operaci贸n de asignaci贸n, podemos usar el nombre de la variable para realizar operaciones con ella, como si fuera del tipo de datos que le hemos asignado. Si asignamos un valor a una variable a la que ya hab铆amos asignado datos, nuestra variable conserva el valor m谩s reciente.

Adem谩s, esta operaci贸n nos permite "guardar" el resultado de operaciones, de modo que los podemos recuperar sin necesidad de realizar las operaciones otra vez. Basta con llamar el nombre de la variable en la consola

En este ejemplo, asignamos valores a las variables `estatura` y `peso`.
```{r}
estatura <- 1.73
peso <- 83
```
Llamamos a sus valores asignados
```{r}
estatura
peso
```

Usamos los valores asignados para realizar operaciones.
```{r}
peso / estatura ^ 2
```

Cambiamos el valor de una variable a uno nuevo y realizamos operaciones
```{r}
peso <- 76

peso

peso / estatura ^ 2

estatura <- 1.56
peso <- 48

peso / estatura ^ 2
```

Asignamos el resultado de una operaci贸n a una variable nueva.
```{r}
bmi <- peso / estatura ^ 2

bmi
```

Como podr谩s ver, es posible asignar a una variable valores de otra variable o el resultado de operaciones con otras variables.
```{r, echo=TRUE}
velocidad_inicial <- 110
velocidad_final <- 185

tiempo_inicial <- 0
tiempo_final <- 15

variacion_velocidad <- velocidad_final - velocidad_inicial
variacion_tiempo <- tiempo_final - tiempo_inicial

variacion_velocidad / variacion_tiempo
```

## Orden de operaciones
En R, al igual que en matem谩ticas, las operaciones tienen un orden de evaluaci贸n definido. 

Cuanto tenemos varias operaciones en una misma expresi贸n, estas no ocurren todas al mismo tiempo, sino en secuencia. 

En la siguiente tabla se presenta el orden en que ocurren las operaciones que hemos revisado en este cap铆tulo, que incluye a las operaciones aritm茅ticas, relacionales, l贸gicas y de asignaci贸n.

Orden |Operaci贸n 
---   |---
1     | `^`
2     | `*` `/`
3     | `+` `-`
4     | `<` `>` `<=` `>=` `==` `!=`
5     | `!`
6     | `&`
7     | `|`
8     | `<-`

Si deseamos que una operaci贸n ocurra antes que otra, rompiendo este orden de evaluaci贸n, usamos par茅ntesis.

```{r parentesis}
# Orden de operaciones regular, multiplicaci贸n y despu茅s suma
1 + 2 * 3
# Indicamos que ocurra primero la suma y despu茅s la multiplicaci贸n
(1 + 2) * 3
```

Tambi茅n podemos usar par茅ntesis anidados y las operaciones ocurrir谩n del par茅ntesis con el nivel m谩s profundo de anidaci贸n, hacia el menos profundo.

* `(((ocurre_primero)ocurre_segundo)ocurre_tercero)`

En la siguiente expresi贸n, se sigue el orden de operaciones regular: primero la resta, despu茅s la multiplicaci贸n y finalmente la potencia.

```{r parentesis_anidados_normal}
2 * 4 - 5 ^ 3
```

Con los par茅ntesis anidados, indicamos que ocurra primero la resta, el nivel m谩s profundo de anidaci贸n, despu茅s la multiplicaci贸n, y finalmente la potencia, el nivel menos profundo de anidaci贸n.

```{r parentesis_anidados}
((2 * (4 - 5)) ^ 4)
```

Podemos cambiar c贸mo anidamos los par茅ntesis,  para que primero ocurra la potencia, despu茅s la resta y finalmente la multiplicaci贸n.

```{r parentesis_anidados_2}
(2 * (4 - (5 ^ 3)))
```


