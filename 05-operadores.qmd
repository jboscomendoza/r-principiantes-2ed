# Operadores {#sec-operadores}
Los operadores son los símbolos que, como nombre lo anticipa, le indican a R que se debe realizar un tipo de operación específica. En todos los lenguajes de programación, los operadores son sumamente importantes, al combinarlos con los datos y sus estructuras es que logramos hacer la mayor parte de nuestro trabajo.

Los tipos de operadores principales en R son los siguientes:

* Aritméticos
* Relacionales
* Lógicos
* De asignación

Familiarizarnos con los operadores nos dará herramientas para manipular y transformar datos. 

Revisemos los diferentes tipos de operador.

## Operadores aritméticos

Este tipo de operador es usado para operaciones aritméticas. En R tenemos disponibles los siguientes operadores, que corresponden a las operaciones aritméticas básicas.

Operador  | Operación       | Ejemplo | Resultado
----      |----             |----     |----
`+`       | Suma            | `5 + 3` | 8
`-`       | Resta           | `5 - 3` | 2
`*`       | Multiplicación  | `5 * 3` | 18
`/`       | División        | `5 /3`  | 1.666667
`^`       | Potencia        | `5 ^ 3` | 125
`%%`      | División entera | `5 %% 3`| 2

Podemos realizar operaciones aritméticas con datos de tipo **entero** y **numérico**.

Si escribimos una operación aritmética en la consola de R y damos *Enter*, la operación se realiza y nos es devuelto su resultado.

```{r operacion_aritmetica_basica}
15 * 3
```

Cuando intentamos realizar una operación aritmética con un tipo de dato que no sea entero o numérico, R primero intentará coercionar ese dato a uno de tipo numérico. Si la coerción es exitosa, se realizará la operación normalmente, y si falla nos devolverá un error.

Por ejemplo, `4 + TRUE` se realizará normalmente, coercionando `TRUE` a `1`.

```{r numerico_coercion}
4 + TRUE
```

En contraste, si intentamos la operación `4 + "1"` se nos devuelve un error.

```{r numerico_cadena}
#| error: true
4 + "1"
```

El mensaje *"non-numeric argument for binary operator"* aparecerá siempre que intentemos realizar una operación aritmética con un argumento no numérico y que no puede coercionarse a tipo numérico. Si nos encontramos con este error, esto nos da una pista para encontrar la raíz del problema.

Cualquier operación aritmética que intentemos con un dato `NA` siempre nos devolverá `NA` como resultado a menos que ocurra un error o un dato sea `NULL`.

```{r numerico_na}
#| error: true
NA - 66

21 * NA

NA ^ 13

"64.3" + NA
```

¿Qué pasa si hacemos una operación con un dato `NULL`? Siempre nos devolverá un vector numérico vacío, incluso si uno de los datos es `NA`, a menos que ocurra un error.

```{r numerico_null}
#| error: true
NULL - 66

21 * NULL

NULL ^ 13

NULL + NA

"64.3" + NULL
```

### La división entera

La división entera o **módulo** es un caso particular de la división, que en lugar de devolver el cociente de la operación, nos devuelve el residuo.

Por ejemplo, si hacemos la división `4 / 2` obtenemos su cociente, `2`.

```{r division_1}
4 / 2
```

Si hacemos una división entera de 4 entre 2, el resultado será 0, por ser una división exacta que no tiene residuo.

```{r division_entera_1}
4 %% 2
```

En cambio, si hacemos una división `5 / 2`, su resultado es `2.5`. Obtenemos una parte decimal en el resultados porque no podemos hacer una división exacta entre estos dos números.

```{r division_2}
5 / 2
```

Por lo tanto, al hacer la división entera de 5 entre 2, el resultado será 1, el residuo de la división.

```{r division_entera_2}
5 %% 2
```

## Operadores relacionales

Los operadores lógicos son usados para hacer comparaciones y siempre devuelven como resultado los valores lógicos `TRUE` o `FALSE` (verdadero o falso, respectivamente).

Operador| Comparación           | Ejemplo   | Resultado
----    |----                   |----       |----
`<`     | Menor que             | `5 < 3`   | `FALSE`
`>`     | Mayor que             | `5 > 3`   | `TRUE`
`<=`    | Menor o igual que     | `5 <= 3`  | `FALSE`
`>=`    | Mayor o igual que     | `5 >= 3`  | `TRUE`
`==`    | Exactamente igual que | `5 == 3`  | `FALSE`
`!=`    | No es igual que       | `5 != 3`  | `TRUE`

### Comparación de datos enteros o numéricos

Al comparar datos enteros o numéricos ocurre una comparación de magnitudes.

```{r comparacion_numerica}
16 > 8.5
16 < 8.5

-16 > -8.5
-16 < -8.5

8.5 >= 8.5
8.5 <= 8.5

8.5 == 8.5
16 == 8.5

16 != 8.5
16 != 8.5
```

### Comparación de cadenas de texto

Cuando usamos los operadores `>`, `>=`, `<` y `<=` con cadenas de texto, se hace una comparación por orden alfabético. 

Por ejemplo, probemos si `"casa"` es mayor que `"barco"`.

```{r comparar_cadenas_1}
"casa" > "barco"
```

En este caso, es verdadero que la palabra "casa" tiene orden alfabético mayor a "barco", pues empieza con "c" y esta letra tiene una posición posterior a la "b" en el alfabeto.

Entonces, si comparamos `"barco" < "casa"` no es devuelto `FALSE`.

```{r comparar_cadenas_2}
"barco" < "casa"
```

La comparación es hecha letra por letra, de modo que `"casa"` tiene un orden alfabético mayor que `"cama"` y menor que `"cava"`.

```{r comparar_cadenas_3}
"casa" > "cama"
"casa" > "cava"
```

Al comparar dos cadenas con `==` ambas deben ser exactamente iguales para que nos sea devuelto `TRUE`, si son parcialmente iguales obtenemos `FALSE`.

```{r comparar_cadenas_4}
"casa" == "casa"
"casa" == "casar"
```

Las comparaciones son sencibles a las letras mayúsculas y minúsculas. Las letras mayúsculas tienen un orden mayor que las minúsculas. 

```{r comparar_mayus}
"C" > "c"
"Barco" > "barco"
"barco" > "barCo"
```

### Comparación de factores

Si intentamos comparar dos factores se nos devuelve un valor `NA` y una advertencia de que la operación de relación no tiene significado para factores.

```{r comparar_factores_1}
factor("1") > factor("2")
```

Esto ocurre incluso cuando comparamos factores que forman parte del mismo vector.

```{r comparar_factores}
vector_factores <- factor(c("1", "2"))

vector_factores

vector_factores[1] > vector_factores[2]
```

### Comparación con datos lógicos

Al comparar valores lógicos, `TRUE` siempre es mayor que `FALSE`.

```{r comparar_logicos_1}
TRUE < FALSE
TRUE > FALSE
```

Naturalmente, `TRUE` y `FALSE` son iguales a sí mismos y diferentes entre sí.

```{r comparar_logicos_2}
TRUE == TRUE
FALSE == FALSE
TRUE == FALSE
TRUE != FALSE
```

### Comparación con NA y NULL

Cualquier comparación con un dato `NA` nos devuelve `NA`, excepto al comparar con `NULL`.

```{r comparar_NA}
NA > 32
NA > "32"
NA > TRUE
```

Por su parte, cualquier comparación un dato `NULL` obtenemos un vector lógico vacío, incluso al comparar con un dato `NA`.

```{r comparar_NULL}
NULL < 32
NULL < "32"
NULL < TRUE
NULL < NA
```

### Comparación con datos de diferentes tipos

Si comparamos un dato numérico con una cadena de texto, el dato entero o numérico es coercionado a una cadena de texto y se seguirán las reglas de comparación para cadenas.

```{r comprar_cadena_numerico}
"1" == 1
"a" > 123000.75
"33" > 40
"33" > 22.1
```
Como las números en una cadena de texto tienen un orden alfabético menor que las letras, generalmente una palabra será mayor que un dato entero o numérico

```{r}
"Alba" > 137018.75
"zócalo" > 137018.75
```

Si comparamos un dato númerico con uno lógico, `TRUE` es coercionado a `1` y `FALSE` a 0.

```{r comparar_logico_numerico}
TRUE == 1
FALSE == 0
TRUE > 24
FALSE > 24
TRUE > -24
FALSE > -24
```

Si comparamos un valor lógico con una cadena de texto, este será coercionado a una cadena de texto, así que se compararán `"TRUE"` y `"FALSE"`, con las reglas de comparación para cadenas de texto.

```{r}
TRUE == "TRUE"
FALSE == "FALSE"
TRUE > "SOGA"
TRUE > "UMBRAL"
FALSE > "ETAPA"
FALSE > "HIGO"
```

## Operadores lógicos

Los operadores lógicos son usados para operaciones de **álgebra Booleana**, es decir, para describir relaciones lógicas, evaluándolas como verdaderas (`TRUE`) o falsas (`FALSE`).

Operador    | Nombre   |Operación                 | Ejemplo        | Resultado
----        |---       |----                      |----            |----
`a | b`     | OR (o)   | a **o** b es verdadero   | `TRUE | FALSE` | `TRUE`
`a & b`     | AND (y)  | a **y** b son verdaderos | `TRUE & FALSE` | `FALSE`
`!a`        | NOT (no, negación) | a **no** es verdadero    | `!TRUE` | `FALSE`

Además tenemos la función `isTRUE()`.

Función     | Operación                      | Ejemplo        | Resultado
---         |---                             |---             |---
`isTRUE(a)` | a **es** verdadero, afirmación | `isTRUE(TRUE)` | `TRUE`

Estos operadores siempre devuelven `TRUE` o `FALSE`, sin importar el tipo de datos en los que se opere.

Los operadores `|` y `&` siguen estas reglas:

* `|` devuelve `TRUE` si cualquiera de los datos es evaluado como `TRUE`
* `&` solo devuelve `TRUE` si ambos datos son evaluados como `TRUE`
* `|` solo devuelve `FALSE` si ambos datos son evaluados como `FALSE`
* `&` devuelve `FALSE` si cualquiera de los datos es evaluado como `FALSE`


Estos operadores pueden ser usados con estos con datos de tipo **numérico**, **lógico** y **complejo**. Al igual que con los operadores relacionales, los operadores lógicos siempre devuelven `TRUE` o `FALSE`.

Para realizar operaciones lógicas, todos los valores numéricos y complejos distintos a `0` son coercionados a `TRUE`, mientras que `0` siempre es coercionado a `FALSE`. 

Por ejemplo, `5 | 0` resulta en `TRUE` y `5 & FALSE` resulta en `FALSE`. Podemos comprobar lo anterior con la función `isTRUE()`.
```{r, echo=TRUE}
5 | 0

5 & 0

isTRUE(0)

isTRUE(5)
```

Estos operadores se pueden combinar para expresar relaciones complejas.

Por ejemplo, la negación `FALSE` Y `FALSE` dará como resultado `TRUE`.
```{r}
!(FALSE | FALSE)
```

También podemos combinar operadores lógicos y relacionales. dado que esto últimos dan como resultado `TRUE` y `FALSE`.


```{r}
(4 < 6) | (6 == 6)
```

## Operadores de asignación
Este es probablemente el operador más importante de todos, pues nos permite asignar datos a variables.

Operador  | Operación   
----      |----         
`<-`      | Asigna un valor a una variable
`=`       | Asigna un valor a una variable

Aunque podemos usar el signo igual para una asignación, a lo largo de este libro utilizaremos `<-`, por ser característico de R y fácil de reconocer visualmente.

Después de realizar la operación de asignación, podemos usar el nombre de la variable para realizar operaciones con ella, como si fuera del tipo de datos que le hemos asignado. Si asignamos un valor a una variable a la que ya habíamos asignado datos, nuestra variable conserva el valor más reciente.

Además, esta operación nos permite "guardar" el resultado de operaciones, de modo que los podemos recuperar sin necesidad de realizar las operaciones otra vez. Basta con llamar el nombre de la variable en la consola

En este ejemplo, asignamos valores a las variables `estatura` y `peso`.
```{r}
estatura <- 1.73
peso <- 83
```
Llamamos a sus valores asignados
```{r}
estatura
peso
```

Usamos los valores asignados para realizar operaciones.
```{r}
peso / estatura ^ 2
```

Cambiamos el valor de una variable a uno nuevo y realizamos operaciones
```{r}
peso <- 76

peso

peso / estatura ^ 2

estatura <- 1.56
peso <- 48

peso / estatura ^ 2
```

Asignamos el resultado de una operación a una variable nueva.
```{r}
bmi <- peso / estatura ^ 2

bmi
```

Como podrás ver, es posible asignar a una variable valores de otra variable o el resultado de operaciones con otras variables.
```{r, echo=TRUE}
velocidad_inicial <- 110
velocidad_final <- 185

tiempo_inicial <- 0
tiempo_final <- 15

variacion_velocidad <- velocidad_final - velocidad_inicial
variacion_tiempo <- tiempo_final - tiempo_inicial

variacion_velocidad / variacion_tiempo
```

## Orden de operaciones
En R, al igual que en matemáticas, las operaciones tienen un orden de evaluación definido. 

Cuanto tenemos varias operaciones en una misma expresión, estas no ocurren todas al mismo tiempo, sino en secuencia. 

En la siguiente tabla se presenta el orden en que ocurren las operaciones que hemos revisado en este capítulo, que incluye a las operaciones aritméticas, relacionales, lógicas y de asignación.

Orden |Operación 
---   |---
1     | `^`
2     | `*` `/`
3     | `+` `-`
4     | `<` `>` `<=` `>=` `==` `!=`
5     | `!`
6     | `&`
7     | `|`
8     | `<-`

Si deseamos que una operación ocurra antes que otra, rompiendo este orden de evaluación, usamos paréntesis.

```{r parentesis}
# Orden de operaciones regular, multiplicación y después suma
1 + 2 * 3
# Indicamos que ocurra primero la suma y después la multiplicación
(1 + 2) * 3
```

También podemos usar paréntesis anidados y las operaciones ocurrirán del paréntesis con el nivel más profundo de anidación, hacia el menos profundo.

* `(((ocurre_primero)ocurre_segundo)ocurre_tercero)`

En la siguiente expresión, se sigue el orden de operaciones regular: primero la resta, después la multiplicación y finalmente la potencia.

```{r parentesis_anidados_normal}
2 * 4 - 5 ^ 3
```

Con los paréntesis anidados, indicamos que ocurra primero la resta, el nivel más profundo de anidación, después la multiplicación, y finalmente la potencia, el nivel menos profundo de anidación.

```{r parentesis_anidados}
((2 * (4 - 5)) ^ 4)
```

Podemos cambiar cómo anidamos los paréntesis,  para que primero ocurra la potencia, después la resta y finalmente la multiplicación.

```{r parentesis_anidados_2}
(2 * (4 - (5 ^ 3)))
```


