# Operadores {#sec-operadores}
Los operadores, como su nombre los indica, son s铆mbolos usados por R para realizar diferentes tipos de operaciones. En todos los lenguajes de programaci贸n, los operadores son sumamente importantes, al combinarlos con los datos y sus estructuras es como logramos hacer la mayor parte de nuestro trabajo.

Los tipos de operadores principales en R son los siguientes:

* Aritm茅ticos
* Relacionales
* L贸gicos
* De asignaci贸n


Revisemos sus caracter铆sticas.

## Operadores aritm茅ticos {#sec-operadores-aritmeticos}

Este tipo de operador es usado para operaciones aritm茅ticas. En R tenemos disponibles los siguientes operadores, que corresponden a las operaciones aritm茅ticas b谩sicas.

Operador  | Operaci贸n       | Ejemplo | Resultado
----      |----             |----     |----
`+`       | Suma            | `5 + 3` | 8
`-`       | Resta           | `5 - 3` | 2
`*`       | Multiplicaci贸n  | `5 * 3` | 18
`/`       | Divisi贸n        | `5 /3`  | 1.666667
`^`       | Potencia        | `5 ^ 3` | 125
`%%`      | Divisi贸n entera | `5 %% 3`| 2

Podemos realizar operaciones aritm茅ticas con datos de tipo **entero** y **num茅rico**.

Si escribimos una operaci贸n aritm茅tica en la consola de R y damos *Enter*, la operaci贸n se realiza y nos es devuelto su resultado.

```{r operacion_aritmetica_basica}
15 * 3
```

Cuando intentamos realizar una operaci贸n aritm茅tica con un tipo de dato que no sea entero o num茅rico, R primero intentar谩 coercionar ese dato a uno de tipo num茅rico. Si la coerci贸n es exitosa, se realizar谩 la operaci贸n normalmente, y si falla nos devolver谩 un error.

Por ejemplo, `4 + TRUE` se realizar谩 normalmente, coercionando `TRUE` a `1`.

```{r numerico_coercion}
4 + TRUE
```

En contraste, si intentamos la operaci贸n `4 + "1"` se nos devuelve un error.

```{r numerico_cadena}
#| error: true
4 + "1"
```

El mensaje *"non-numeric argument for binary operator"* aparecer谩 siempre que intentemos realizar una operaci贸n aritm茅tica con un argumento no num茅rico y que no puede coercionarse a tipo num茅rico. Si nos encontramos con este error, esto nos da una pista para encontrar la ra铆z del problema.

Cualquier operaci贸n aritm茅tica que intentemos con un dato `NA` siempre nos devolver谩 `NA` como resultado a menos que ocurra un error o un dato sea `NULL`.

```{r numerico_na}
#| error: true
NA - 66

21 * NA

NA ^ 13

"64.3" + NA
```

驴Qu茅 pasa si hacemos una operaci贸n con un dato `NULL`? Siempre nos devolver谩 un vector num茅rico vac铆o, incluso si uno de los datos es `NA`, a menos que ocurra un error.

```{r numerico_null}
#| error: true
NULL - 66

21 * NULL

NULL ^ 13

NULL + NA

"64.3" + NULL
```

### La divisi贸n entera {#sec-operadores-aritmeticos-divisionentera}

La divisi贸n entera o **m贸dulo** es un caso particular de la divisi贸n, que en lugar de devolver el cociente de la operaci贸n, nos devuelve el residuo.

Por ejemplo, si hacemos la divisi贸n `4 / 2` obtenemos su cociente, `2`.

```{r division_1}
4 / 2
```

Si hacemos una divisi贸n entera de 4 entre 2, el resultado ser谩 0, por ser una divisi贸n exacta que no tiene residuo.

```{r division_entera_1}
4 %% 2
```

En cambio, si hacemos una divisi贸n `5 / 2`, su resultado es `2.5`. Obtenemos una parte decimal en el resultados porque no podemos hacer una divisi贸n exacta entre estos dos n煤meros.

```{r division_2}
5 / 2
```

Por lo tanto, al hacer la divisi贸n entera de 5 entre 2, el resultado ser谩 1, el residuo de la divisi贸n.

```{r division_entera_2}
5 %% 2
```

## Operadores relacionales {#sec-operadores-relacionales}

Los operadores l贸gicos son usados para hacer comparaciones y siempre devuelven como resultado los valores l贸gicos `TRUE` o `FALSE` (verdadero o falso, respectivamente).

Operador| Comparaci贸n           | Ejemplo   | Resultado
----    |----                   |----       |----
`<`     | Menor que             | `5 < 3`   | `FALSE`
`>`     | Mayor que             | `5 > 3`   | `TRUE`
`<=`    | Menor o igual que     | `5 <= 3`  | `FALSE`
`>=`    | Mayor o igual que     | `5 >= 3`  | `TRUE`
`==`    | Exactamente igual que | `5 == 3`  | `FALSE`
`!=`    | No es igual que       | `5 != 3`  | `TRUE`

### Comparaci贸n de datos enteros o num茅ricos {#sec-operadores-relacionales-numero}

Al comparar datos enteros o num茅ricos ocurre una comparaci贸n de magnitudes.

```{r comparacion_numerica}
16 > 8.5
16 < 8.5

-16 > -8.5
-16 < -8.5

8.5 >= 8.5
8.5 <= 8.5

8.5 == 8.5
16 == 8.5

8.5 != 8.5
16 != 8.5
```

### Comparaci贸n de cadenas de texto {#sec-operadores-relacionales-texto}

Cuando usamos los operadores `>`, `>=`, `<` y `<=` con cadenas de texto, se hace una comparaci贸n por orden alfab茅tico. 

Por ejemplo, probemos si `"casa"` es mayor que `"barco"`.

```{r comparar_cadenas_1}
"casa" > "barco"
```

En este caso, es verdadero que la palabra "casa" tiene orden alfab茅tico mayor a "barco", pues empieza con "c" y esta letra tiene una posici贸n posterior a la "b" en el alfabeto.

Entonces, si comparamos `"barco" < "casa"` no es devuelto `FALSE`.

```{r comparar_cadenas_2}
"barco" < "casa"
```

La comparaci贸n es hecha letra por letra, de modo que `"casa"` tiene un orden alfab茅tico mayor que `"cama"` y menor que `"cava"`.

```{r comparar_cadenas_3}
"casa" > "cama"
"casa" > "cava"
```

Al comparar dos cadenas con `==` ambas deben ser exactamente iguales para que nos sea devuelto `TRUE`, si son parcialmente iguales obtenemos `FALSE`.

```{r comparar_cadenas_4}
"casa" == "casa"
"casa" == "casar"
```

Las comparaciones son sensibles a las letras may煤sculas y min煤sculas. Las letras may煤sculas tienen un orden mayor que las min煤sculas. 

```{r comparar_mayus}
"C" > "c"
"Barco" > "barco"
"barco" > "barCo"
```

### Comparaci贸n de factores {#sec-operadores-relacionales-factor}

Si intentamos comparar dos factores se nos devuelve un valor `NA` y una advertencia de que la operaci贸n de relaci贸n no tiene significado para factores.

```{r comparar_factores_1}
factor("1") > factor("2")
```

Esto ocurre incluso cuando comparamos factores que forman parte del mismo vector.

```{r comparar_factores}
vector_factores <- factor(c("1", "2"))

vector_factores

vector_factores[1] > vector_factores[2]
```

### Comparaci贸n con datos l贸gicos {#sec-operadores-relacionales-logico}

Al comparar valores l贸gicos, `TRUE` siempre es mayor que `FALSE`.

```{r comparar_logicos_1}
TRUE < FALSE
TRUE > FALSE
```

Naturalmente, `TRUE` y `FALSE` son iguales a s铆 mismos y diferentes entre s铆.

```{r comparar_logicos_2}
TRUE == TRUE
FALSE == FALSE
TRUE == FALSE
TRUE != FALSE
```

### Comparaci贸n con NA y NULL {#sec-operadores-relacionales-nanull}

Cualquier comparaci贸n con un dato `NA` nos devuelve `NA`, excepto al comparar con `NULL`.

```{r comparar_NA}
NA > 32
NA > "32"
NA > TRUE
```

Por su parte, cualquier comparaci贸n un dato `NULL` obtenemos un vector l贸gico vac铆o, incluso al comparar con un dato `NA`.

```{r comparar_NULL}
NULL < 32
NULL < "32"
NULL < TRUE
NULL < NA
```

### Comparaci贸n con datos de diferentes tipos {#sec-operadores-relacionales-otros}

Si comparamos un dato num茅rico con una cadena de texto, el dato entero o num茅rico es coercionado a una cadena de texto y se seguir谩n las reglas de comparaci贸n para cadenas.

```{r comprar_cadena_numerico}
"1" == 1
"a" > 123000.75
"33" > 40
"33" > 22.1
```
Como las n煤meros en una cadena de texto tienen un orden alfab茅tico menor que las letras, generalmente una palabra ser谩 mayor que un dato entero o num茅rico

```{r}
"Alba" > 137018.75
"z贸calo" > 137018.75
```

Si comparamos un dato n煤merico con uno l贸gico, `TRUE` es coercionado a `1` y `FALSE` a 0.

```{r comparar_logico_numerico}
TRUE == 1
FALSE == 0
TRUE > 24
FALSE > 24
TRUE > -24
FALSE > -24
```

Si comparamos un valor l贸gico con una cadena de texto, este ser谩 coercionado a una cadena de texto, as铆 que se comparar谩n `"TRUE"` y `"FALSE"`, con las reglas de comparaci贸n para cadenas de texto.

```{r comparar_cadenas}
TRUE == "TRUE"
FALSE == "FALSE"
TRUE > "SOGA"
TRUE > "UMBRAL"
FALSE > "ETAPA"
FALSE > "HIGO"
```

## Operadores l贸gicos {#sec-operadores-logicos}

Los operadores l贸gicos son usados para operaciones de **谩lgebra Booleana**, es decir, para describir relaciones l贸gicas, evalu谩ndolas como verdaderas (`TRUE`) o falsas (`FALSE`). 

Operador    | Nombre   |Operaci贸n                 | Ejemplo        | Resultado
----        |---       |----                      |----            |----
`a | b`     | O (OR)   | a **o** b es verdadero   | `TRUE | FALSE` | `TRUE`
`a & b`     | Y (AND)  | a **y** b son verdaderos | `TRUE & FALSE` | `FALSE`
`!a`        | NO (NOT) | a **no** es verdadero    | `!TRUE`        | `FALSE`

Estos operadores siempre devuelven `TRUE` o `FALSE`, sin importar el tipo de datos con los que se opere.

Los operadores `|` y `&` siguen estas reglas:

* `|` devuelve `TRUE` si cualquiera de los datos es evaluado como `TRUE`
* `&` solo devuelve `TRUE` si ambos datos son evaluados como `TRUE`
* `|` solo devuelve `FALSE` si ambos datos son evaluados como `FALSE`
* `&` devuelve `FALSE` si cualquiera de los datos es evaluado como `FALSE`

Adem谩s tenemos la funci贸n `isTRUE()` que comprueba si un valor es `TRUE`.

Funci贸n     | Operaci贸n                      | Ejemplo        | Resultado
---         |---                             |---             |---
`isTRUE(a)` | a **es** verdadero, afirmaci贸n | `isTRUE(TRUE)` | `TRUE`

### Operadores l贸gicos y evaluaci贸n de expresiones {#sec-operadores-logicos-expresiones}

En un sentido estricto, al usar estos operadores estamos combinando dos valor booleanos, pero una forma de entender estos operadores es que evaluan la veracidad ("truthiness", en ingl茅s) de dos objetos al mismo tiempo.

Cuando nuestros objetos son datos son de tipo l贸gico, esta evaluaci贸n es muy transparente, `TRUE | FALSE` nos devuelve `TRUE` mientras que `TRUE | FALSE` nos devuelve `TRUE`. Sin embargo, como podemos usar estos operadores con cualquier tipo de datos, estos primero se evaluan a `TRUE` or `FALSE` y lo mismo es cierto para el resultado de otras operaciones o funciones. 

Para explicar esto un poco m谩s, supongamos que tenemos dos mascotas, una llamada Menchi y la otra Tlaloc, que tienen los atributos que se muestran en la siguiente tabla.

Atributo         | Menchi  | Tlaloc 
---              |---        |---
Clase            | Mam铆fero  | Mam铆fero
Especie          | Perro     | Gato
Sexo             | Hembra    | Macho
N煤mero de patas  | 4         | 4
Pelaje           | Corto     | Largo

Vamos a evaluar algunas aformaciones sobre Menchi y Tlaloc.

* Menchi Y (`&`) Tlaloc son Mam铆feros

Tenemos que evaluar el atributo "Clase" de cada uno de ellos

* 驴La Clase de Menchi es Mamifero? Verdadero (`TRUE`)
* 驴La Clase de Tlaloc es Mamifero? Verdadero (`TRUE`)

Entonces:

* Menchi == `TRUE`
* Tlaloc == `TRUE`

Que podr铆amos representar as铆:

* `TRUE & TRUE` 

Que nos da como resultado `TRUE`. Es decir, es Verdadero que Menchi y Tlaloc son Mam铆feros.

Evalu茅mos una segunda afirmaci贸n:

* Menchi Y (`&`) Tlaloc son Perros

De nuevo, evaluamos el atributo correspondiente de ambos:

* 驴La Especie de Menchi es Perro? Verdadero (`TRUE`)
* 驴La Especie de Tlaloc es Gato? Falso (`FALSE`)

Entonces:

* Menchi == `TRUE`
* Tlaloc == `FALSE`

Y, por lo tanto:

* `TRUE & FALSE`

Que nos da como resultado `FALSE`. Es decir, es Falso que Menchi y Tlaloc son Perros.

Cambiemos nuestra afirmaci贸n:

* Menchi O (`|`) Tlaloc son Perros

No suena muy natural si lo decimos de esta manera. Cambiemos la formulaci贸n:

* Menchi O (`|`) Tlaloc es un Perro

Como ya vimos, para que el operador `|` (O, OR) devuelva `TRUE`, basta con que cualquier elementos sea `TRUE`, as铆 que podemos expresar esta afirmaci贸n de esta manera.

Ya conocemos el resultado de evaluar el atributo Especia de Menchi y Tlaloc.

* Menchi == `TRUE`
* Tlaloc == `FALSE`

Por lo tanto:

* `TRUE | FALSE`

Que nos da como resultado `TRUE`. Es decir, es Verdadero que Menchi o Tlaloc es un Perro.

Finalmente, tenemos una afirmaci贸n que usa `!` (NO, NOT).

* Menchi No (`!`) es Macho

En este ejemplo, esta afirmaci贸n es f谩cil de evaluar, pues s贸lo tenemos que mirar el atributo correspondiente para llegar al resultado `TRUE`, es Verdadero que Menchi No es Macho.

Pero podemos combinar esta afirmaci贸n otra, sobre Tlaloc.

* Menchi No (!) es Macho Y (`&`) Tlaloc es Macho

Sabemos que es Verdadero que Tlaloc es Macho, por lo tanto:

* `TRUE & TRUE` 

Que nos da como resultado `TRUE`, es Verdadero que Menchi No es Macho y Tlaloc es Macho.

Aun hay otras que puedes intentar identificar como ejercicio con las caracter铆sticas de Menchi y Tlaloc. Adem谩s este 煤ltimo ejemplo es una peque帽a muestra de lo complejas que pueden ser las operaciones l贸gicas y en la siguiente secci贸n veremos c贸mo se combinan con operaciones relacionales.

### Operadores l贸gicos con operadores relacionales {#sec-operadores-logicos-relaciones}

Podemos combinar los operadores l贸gicos con operadores relacionales para evaluar expresiones complejas.

Como el resultado de una operaci贸n relacional es `TRUE` or `FALSE`, podemos evaluar expresiones como la siguiente.

```{r logicos_relacionales_1}
(4 < 6) & (6 > 4)
```

Obtenemos como resultado `TRUE`, porque ambos elementos son verdaderos.

```{r logicos_relacionales_2}
4 < 6
6 > 4
```

Por supuesto, podemos tener expresiones con datos no num茅ricos y operadores relacionales.

```{r relaci贸n_otros_datos_1}
("Pluma" == "L谩piz") | ("L谩piz" != "Hoja")
```

Obtenemos `TRUE` porque al menos uno de los dos elementos es verdadero.

```{r relaci贸n_otros_datos_2}
"Pluma" == "L谩piz"
"L谩piz" != "Hoja"
```

Hemos usado par茅ntesis para establecer el orden en que deben ocurrir las operaciones, esto lo revisaremos en la [Secci贸n @sec-operadores-orden-operaciones] de este mismo cap铆tulo.

### Operadores l贸gicos con datos enteros y num茅ricos {#sec-operadores-logicos-numero}

Como revisamos en la [Secci贸n @sec-datos-coercion], los datos enteros y num茅ricos pueden ser coercionados a l贸gicos. Todos los valores enteros y num茅ricos distintos a `0` son coercionados a `TRUE`, mientras que `0` siempre es coercionado a `FALSE`.

Por ejemplo, `5 | 0` devuelve `TRUE` porque el n煤mero `5` es coercionado a `TRUE` y `0` es conercionado a `FALSE.

```{r coercion_numerico}
5 | 0
```

Podemos comprobar lo anterior con la funci贸n `isTRUE()`.

```{r coercion_istrue}
isTRUE(0)
isTRUE(5)
```

Por lo tanto, `5 | FALSE` devuelve `TRUE` y `0 & TRUE` devuelve `FALSE`.

```{r}
5 | FALSE
0 & FALSE
```

### Operadores l贸gicos con cadenas de texto {#sec-operadores-logicos-texto}

Si intentamos una operaci贸n l贸gica con una cadena de texto obtenemos siempre un error.

```{r logico_error}
#| error: true
"TRUE" & FALSE
"FALSE" | TRUE
"a" | FALSE
"Z" & TRUE
!"casa"
```

### Operadores l贸gicos con NA y NULL {#sec-operadores-logicos-nanull}

Al usar el operador `|` (OR), si cualquiera de los datos es `TRUE`, obtenemos `TRUE` aunque el otro dato sea `NA`.

```{r OR_NA_NULL_TRUE}
NA | TRUE
```

Pero si un dato es `NA` y el otro es `FALSE`, obtenemos `NA`.

```{r OR_NA_NULL_FALSE}
NA | FALSE
```

Y si un dato es `NULL` obtenemos un vector l贸gico vac铆o.

```{r OR_NULL_FALSE}
NULL | FALSE
```

Para el caso de `&` (AND), si uno de los datos es `NA` y el otro es `TRUE` obtenemos `NA`, y si el otro es `FALSE` obtenemos False.

```{r AND_NA}
NA & TRUE
NA & FALSE
```

Si uno es de los datos es `NULL`, obtenemos un vector l贸gico vac铆o.

```{r AND_NULL}
NULL & TRUE
NULL & FALSE
```

Si negamos `NA` con `!` (NOT) obtenemos `NA`.

```{r NOT_NA}
!NA
```

Pero si negamos `NULL` se nos devuelve un error.

```{r NOT_NULL}
#| error: true
!NULL
```

## Operadores de asignaci贸n {#sec-operadores-asignacion}

Este es probablemente el tipo de operador m谩s importante de todos porque nos permite asignar datos y funciones a variables para despu茅s trabajar con ellas.

Estos operadores asignan el valor que se encuentra a su derecha a la variable que se encuentra a su izquierda.

Operador  | Operaci贸n   
----      |----         
`<-`      | Asigna un valor a una variable
`=`       | Asigna un valor a una variable

A lo largo de este libro utilizaremos `<-` para asignaciones por ser caracter铆stico de R y el que m谩s frecuentemente encontraremos en c贸digo de otras personas. Adem谩s, tiene la ventaja de que es muy expresivo visualmente.

Veamos una asignaci贸n. Asignaremos el valor `1` a la variable `uno`.

```{r asignaci贸n_b谩sica_2}
uno <- 1
```

Si llamamos a la variable `uno` nos es devuelto el valor que tiene asignado.

```{r asignaci贸n_basica_1}
uno
```

Despu茅s de realizar la operaci贸n de asignaci贸n podemos usar el nombre de la variable para realizar operaciones con ella, como si fuera del tipo de datos que le hemos asignado. Si asignamos un valor a una variable a la que ya hab铆amos asignado datos, nuestra variable conservar谩 el valor m谩s reciente.

Esta operaci贸n tambi茅n nos permite "guardar" el resultado de operaciones, de modo que los podemos recuperar sin necesidad de ejecutar las operaciones otra vez. Es suficiente llamar el nombre de la variable para que nos devuelva los valores que ha "guardado".

Ahora asignaremos valores num茅ricos a las variables `estatura` y `peso`.

```{r estatura_peso_1}
estatura <- 1.73
peso <- 83
```

Llamamos a las variables para que nos sean devueltos sus valores asignados.

```{r estatura_peso_2}
estatura
peso
```

Ahora podemos usar estas variables para realizar operaciones. Dividimos peso entre estatura elevada al cuadrado.

```{r estatura_peso_3}
peso / estatura ^ 2
```

Cambiamos el valor de una variable a uno nuevo y realizamos operaciones, mostrando que se ha conservado el 煤ltimo valor asignado a ellas.

```{r estatura_peso_4}
peso <- 76

peso

peso / estatura ^ 2

estatura <- 1.56
peso <- 48

peso / estatura ^ 2
```

Tambi茅n podemos asignar el resultado de una operaci贸n a una variable nueva, en este caso una llamada `imc`, por "铆ndice de masa corporal".

```{r estatura_peso_5}
imc <- peso / estatura ^ 2

imc
```

De esta manera ya tenemos una forma sencilla para calcular el 铆ndice de masa corporal de una persona.

Tambi茅n podemos observar que es posible asignarle a una variable los valores de otra variable o el resultado de operaciones hechas con otras variables, lo cual nos abre la posibilidad de operaciones complejas.

Veamos otro ejemplo, en el que hacemos varias operaciones para obtener el valor de rapidez.

```{r rapidez}
velocidad_inicial <- 110
velocidad_final <- 185

tiempo_inicial <- 0
tiempo_final <- 15

variacion_velocidad <- velocidad_final - velocidad_inicial
variacion_tiempo <- tiempo_final - tiempo_inicial

rapidez <- variacion_velocidad / variacion_tiempo

rapidez
```

Por supuesto, podemos asignar `NA` o `NULL` a variables.

```{r asignacion_na_null}
variable_na <- NA
variable_na
variable_null <- NULL
variable_null
```

No podemos asignar un valor a valor, si lo intentamos nos es devuelto un error.

```{r error_asignaci贸n}
#| error = TRUE
33 <- TRUE
TRUE <- 77
NA <- 94.1
```

Sin embargo, si intentamos asignar un valor a una cadena de texto, no se nos devuelve un error ni una advertencia.

```{r asignacion_texto_1}
"variable_texto" <- 512
```

Pero si llamamos a `"variable_texto"` nos es devuelto `"variable_texto"`.

```{r asignacion_texto_2}
"variable_texto"
```

驴Qu茅 ha ocurrido?

En realidad, la asignaci贸n s铆 ha ocurrido, pero a una variable llamada `variable_texto`, no a la cadena de texto.

```{r asignacion_texto_3}
variable_texto
```

Esto se debe a la forma en que R eval煤a los nombres de variables y explicarlo va m谩s all谩 del alcance de un texto para principiantes, as铆 que s贸lo recordemos que este comportamiento inesperado existe para evitarnos sorpresas en el futuro.

## Orden de operaciones {#sec-operadores-orden}

En R, al igual que en matem谩ticas, las operaciones tienen un orden o jerarqu铆a de evaluaci贸n definido. Cuanto tenemos varias operaciones en una misma expresi贸n, estas no ocurren todas al mismo tiempo, sino en secuencia. 

En la siguiente tabla se presenta el orden en que ocurren las operaciones que hemos revisado en este cap铆tulo.

Orden |Operaci贸n 
---   |---
1     | `^`
2     | `*` `/`
3     | `+` `-`
4     | `<` `>` `<=` `>=` `==` `!=`
5     | `!`
6     | `&`
7     | `|`
8     | `<-`

Si tenemos el mismo operador varias veces en una misma expresi贸n, estos se eval煤an de izquierda a derecha.

En el siguiente ejemplo, primero se resta `10` a `20` y despu茅s `5` al resultado de esa operaci贸n.

```{r}
20 - 10 - 5
```

Si agregamos una multiplicaci贸n a la expresi贸n, primero ocurre la multiplicaci贸n de `10` por `5`, despu茅s la resta de `20` menos su resultado y, finalmente, el resultado de esa operaci贸n menos `5`.

```{r}
20 - 10 * 2 - 5
```

Si en una misma expresi贸n tenemos una multiplicaci贸n (`*`) y una divisi贸n (`/`), se eval煤an de izquieda a derecha. 

En este ejemplo, primero la multiplicaci贸n y despu茅s de la divisi贸n.

```{r orden_mult_div_1}
4 * 3 / 2
```

Y en este ejemplo, primero la divisi贸n y luego la multiplicaci贸n.

```{r orden_mult_div_2}
4 / 3 * 2
```

Lo mismo aplica para la suma (`+`) y la resta (`-`).

Primero la suma y despu茅s de la resta.

```{r orden_suma_resta_1}
4 + 3 - 2
```

Primero la resta y despu茅s la suma.

```{r orden_suma_resta_2}
4 - 3 + 2
```

En el caso de los operadores de comparaci贸n, si una expresi贸n tiene m谩s de un s铆mbolo de este tipo, nos es devuelto un error, a menos que usemos par茅ntesis.

```{r orden_comparacion_1}
#| error: true
23 > 26 == 28
```

El orden de evaluaci贸n de los operadores l贸gicos puede ser un poco desafiante al principio, como en expresiones como la siguiente.

```{r orden_logicos_1}
#| eval: false
FALSE | FALSE & TRUE & TRUE | TRUE
```

Pero si recordamos el orden de operaciones y que s铆mbolos iguales se eval煤an de izquierda a derecha, podemos anticipar que el resultado final es `TRUE`, porque:

1. `FALSE & TRUE` es `FALSE`, entonces
2. `FALSE & TRUE` es `FALSE`, entonces
3. `FALSE | FALSE` es `FALSE`, entonces
4. `FALSE | TRUE` es `TRUE`

Comprobemos lo anterior.

```{r orden_logico_2}
FALSE | FALSE & TRUE & TRUE | TRUE
```

Por supuesto, podemos usar par茅ntesis para facilitar la lectura, adem谩s de para establecer un orden de operaci贸n propio.


### Par茅ntesis {#sec-operadores-orden-parentesis}

Si deseamos que una operaci贸n ocurra antes que otra, rompiendo el orden definido de evaluaci贸n, o para hacerla la m谩s f谩cil de leer, usamos par茅ntesis.

En el orden de operaciones definido, ocurre primero la multiplicaci贸n y despu茅s suma

```{r parentesis_simple_1}
1 * 2 + 3
```

Si encerramos entre par茅ntesis la suma, esta ocurrira primero y despu茅s la multiplicaci贸n

```{r parentesis_simple_2}
1 * (2 + 3)
```

Tambi茅n podemos usar par茅ntesis anidados, de este modo las operaciones ocurrir谩n del par茅ntesis con el nivel m谩s profundo de anidaci贸n, hacia el nivel menos profundo.

* `(((ocurre_primero)ocurre_segundo)ocurre_tercero)`

En la siguiente expresi贸n, se sigue el orden de operaciones regular: primero la resta, despu茅s la multiplicaci贸n y finalmente la potencia.

```{r parentesis_anidados_normal}
2 * 4 - 5 ^ 3
```

Con los par茅ntesis anidados, indicamos que ocurra primero la resta, el nivel m谩s profundo de anidaci贸n, despu茅s la multiplicaci贸n, y finalmente la potencia, el nivel menos profundo de anidaci贸n.

```{r parentesis_anidados}
((2 * (4 - 5)) ^ 4)
```

Podemos cambiar c贸mo anidamos los par茅ntesis,  para que primero ocurra la potencia, despu茅s la resta y finalmente la multiplicaci贸n.

```{r parentesis_anidados_2}
(2 * (4 - (5 ^ 3)))
```

Si tenemos par茅ntesis tanto en el lado izquierdo como en el derecho de una operador, las operaciones dentro de los par茅ntesis son evaluadas primero y despu茅s las operaciones fuera de ellos.

```{r}
(4 - 2) * (8 - 4)
(4 / 2) ^ (8 / 4)
```

Este ha sido un cap铆tulo largo, pero los operadores es un aspecto fundamental para escribir c贸digo, no solo en R, sino en cualquier lenguaje de programaci贸n, por lo que vale la pena dedicar tiempo para comprenderlos.